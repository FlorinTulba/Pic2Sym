/******************************************************************************
 The application Pic2Sym approximates images by a
 grid of colored symbols with colored backgrounds.

 Copyrights from the libraries used by the program:
 - (c) 2003 Boost (www.boost.org)
     License: doc/licenses/Boost.lic
     http://www.boost.org/LICENSE_1_0.txt
 - (c) 2015-2016 OpenCV (www.opencv.org)
     License: doc/licenses/OpenCV.lic
     http://opencv.org/license/
 - (c) 1996-2002, 2006 The FreeType Project (www.freetype.org)
     License: doc/licenses/FTL.txt
     http://git.savannah.gnu.org/cgit/freetype/freetype2.git/plain/docs/FTL.TXT
 - (c) 1997-2002 OpenMP Architecture Review Board (www.openmp.org)
   (c) Microsoft Corporation (implementation for OpenMP C/C++ v2.0 March 2002)
     See: https://msdn.microsoft.com/en-us/library/8y6825x5.aspx
 - (c) 1995-2017 zlib software (Jean-loup Gailly and Mark Adler - www.zlib.net)
     License: doc/licenses/zlib.lic
     http://www.zlib.net/zlib_license.html


 (c) 2016-2019 Florin Tulba <florintulba@yahoo.com>

 This program is free software: you can use its results,
 redistribute it and/or modify it under the terms of the GNU
 Affero General Public License version 3 as published by the
 Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program ('agpl-3.0.txt').
 If not, see: http://www.gnu.org/licenses/agpl-3.0.txt .
 *****************************************************************************/

#include "precompiled.h"

#ifndef UNIT_TESTING

#include "appStart.h"
#include "controlPanelActionsBase.h"
#include "controller.h"
#include "imgSettingsBase.h"
#include "matchSettingsBase.h"
#include "ompTraceSwitch.h"
#include "settings.h"
#include "study.h"
#include "symSettingsBase.h"

#pragma warning(push, 0)

#include <omp.h>

#include <filesystem>
#include <fstream>
#include <optional>

#include <opencv2/imgcodecs/imgcodecs.hpp>

#pragma warning(pop)

using namespace std;
using namespace cv;
using namespace std::filesystem;

/// Proper usage
void showUsage() noexcept;

/// Prevents closing the console before the user sees an error message
void pauseAfterError() noexcept;

/// Presents the misidentified symbols
void viewMismatches(const string& testTitle, const Mat& mismatches) noexcept;

/// Presents the misfiltered symbols
void viewMisfiltered(const string& testTitle, const Mat& misfiltered) noexcept;

extern const string copyrightText;
extern bool AllowReprocessingCases;

#ifdef GENERATE_OPEN_MP_TRACE
/// Definition of the lock for tracing messages generated by ompPrintf()
omp_lock_t ompTraceLock;
#endif  // defined(GENERATE_OPEN_MP_TRACE)

namespace {
const string hBar(80, '=');

/// Displays Copyright text
void copyrightNotice() noexcept {
  cout << hBar << '\n';
  cout << copyrightText << '\n';
  cout << hBar << '\n' << endl;
}

/// Normal mode launch
void normalLaunch() noexcept {
  // Ensure control over the number of threads during the application
  if (omp_get_dynamic())
    omp_set_dynamic(0);

  // Use as many threads as processors
  omp_set_num_threads(omp_get_num_procs());

  // Ensure no nested parallelism
  if (omp_get_nested())
    omp_set_nested(0);

#ifdef GENERATE_OPEN_MP_TRACE
  // Initialize lock for trace messages generated by ompPrintf()
  omp_init_lock(&ompTraceLock);
#endif  // defined(GENERATE_OPEN_MP_TRACE)

  copyrightNotice();

  Settings s;
  Controller c(s);
  Controller::handleRequests();

#ifdef GENERATE_OPEN_MP_TRACE
  omp_destroy_lock(&ompTraceLock);
#endif  // defined(GENERATE_OPEN_MP_TRACE)
}

/// Perform an image transformation under certain conditions.
void timingScenario(
    const string& caseName,      ///< title of the scenario
    const string& settingsPath,  ///< path towards a `p2s` file prescribing the
                                 ///< settings for the transformation
    const string& imgPath,       ///< the image to transform
    const string& reportFilePath =
        ""  ///< the file where to report the duration
    ) noexcept {
  AllowReprocessingCases = true;

  Settings s;
  Controller c(s);
  IControlPanelActions& cpa = c.getControlPanelActions();

  if (!cpa.loadSettings(settingsPath)) {
    cerr << caseName << "\tCouldn't load settings from `" << settingsPath << '`'
         << endl;
    return;
  }

  if (!cpa.newImage(imgPath, true)) {
    cerr << caseName << "\tCouldn't load the image `" << imgPath << '`' << endl;
    return;
  }

  cpa.newSymsBatchSize(0);  // ensure no drafts

  double durationS;
  if (!cpa.performTransformation(&durationS)) {
    cerr << caseName << "\tCouldn't start the transformation!" << endl;
    return;
  }

  if (!reportFilePath.empty()) {
    ofstream ofs(reportFilePath, ios::app);
    ofs << caseName << '\t' << durationS << endl;
  }
}

/// Returns the Mat object contained within the Unit Testing report.
optional<const Mat> contentOfReport(const string& testTitle,
                                    const string& contentDirName) noexcept {
  path contentDir(path(".").append("UnitTesting").append(contentDirName));
  if (!exists(contentDir)) {
    cerr << "Expected work directory: <SolutionDir>/x64/<ConfigType>/ , "
            "but the actual one is: "
         << absolute(".") << ".\nIt has to contain folder 'UnitTesting'."
         << endl;
    pauseAfterError();
    return nullopt;
  }

  path contentFile(absolute(contentDir).append(testTitle).concat(".jpg"));
  if (!exists(contentFile)) {
    cerr << "There has to be a jpg file with the provided <testTitle> ("
         << testTitle << "), but file " << contentFile << " doesn't exist!"
         << endl;
    pauseAfterError();
    return nullopt;
  }

  const Mat content =
      imread(contentFile.string(), ImreadModes::IMREAD_UNCHANGED);
  if (content.empty()) {
    cerr << "Invalid jpg file for " << contentDirName << ": " << contentFile
         << '.' << endl;
    pauseAfterError();
    return nullopt;
  }

  return content;
}

/**
View Mismatches Launch mode opens a Comparator window allowing the developer to
observe the less fortunate approximations of reference patches.

testTitle is the title of the Comparator window and
is also the stem of the jpg file handled by the Comparator.
*/
void viewMismatchesMode(const string& testTitle) noexcept {
  optional<const Mat> mismatches = contentOfReport(testTitle, "Mismatches");
  if (!mismatches)
    return;

  viewMismatches(testTitle, mismatches.value());
}

/**
View Misfiltered symbols Launch mode opens a window allowing the developer to
observe the less fortunate filtered symbols.

testTitle is the title of the window and
is also the stem of the jpg file handled by the viewer.
*/
void viewMisfilteredMode(const string& testTitle) noexcept {
  optional<const Mat> misfiltered = contentOfReport(testTitle, "Misfiltered");
  if (!misfiltered)
    return;

  viewMisfiltered(testTitle, misfiltered.value());
}
}  // anonymous namespace

/**
Starts the application in:
- study mode, when studying() is configured to return true from 'study.cpp'
- normal mode when there are no parameters
- timing mode when there are 5 parameters (how long it takes transforming an
image in a certain context)
- unit test mode for 2 provided parameters

Next to 'Pic2Sym.exe' there should be:
- res/ folder with the resources required by the application
- Pic2Sym.exe.local/ folder with the used non-system dll-s (basic Dll
redirection mechanism)

When serving the UnitTesting project, Pic2Sym.exe is called from the post-build
process of unit testing. There were 2 approaches for using Pic2Sym.exe as helper
for UnitTesting project:

I. The current method for presenting the issues found by unit testing is to
register them in a file and visualize its entries when unit testing finishes.

II. Previous approach was to invoke 'Pic2Sym.exe' through a detached process
(using CreateProcess). However, after introducing the Dll redirection mechanism:
- calling separately 'Pic2Sym.exe' with the parameters for unit testing worked
as expected
- calling 'Pic2Sym.exe' from unit testing as a detached process couldn't
localize 'qwindows.dll' from Qt. For details about that, see function
providePrivateDLLsPaths() from appStart.cpp
*/
int main(int argc, char* argv[]) {
  AppStart::prepareEnv(argv[0]);  // argv[0] is a path ending in 'Pic2Sym.exe'

  // Some matters need separate studying. In that case, studying() should return
  // true. However, the study mode should be ignored when launching Pic2Sym from
  // UnitTesting or when timing scenarios, that is when the command parameters
  // look like:
  //	- mismatches ...
  //	- misfiltered ...
  //	- timing ...
  bool ignoreStudyMode = false;

  if (1 == argc) {  // no parameters
    if (!studying())
      normalLaunch();

  } else {
    const string firstParam(argv[1ULL]);
    if (3 == argc) {  // 2 parameters
      const string secondParam(argv[2ULL]);

      if (firstParam == "mismatches") {
        viewMismatchesMode(secondParam);
        ignoreStudyMode = true;

      } else if (firstParam == "misfiltered") {
        viewMisfilteredMode(secondParam);
        ignoreStudyMode = true;

      } else if (!studying()) {
        cerr << "Invalid first parameter '" << firstParam << '\'' << endl;
        showUsage();
      }

    } else if (6 == argc) {  // 5 parameters
      if (firstParam == "timing") {
        timingScenario(argv[2ULL], argv[3ULL], argv[4ULL], argv[5ULL]);
        ignoreStudyMode = true;

      } else if (!studying()) {
        cerr << "Invalid first parameter '" << firstParam << '\'' << endl;
        showUsage();
      }

    } else if (!studying()) {  // Wrong # of parameters
      cerr << "There were " << argc - 1 << " parameters!" << endl;
      showUsage();
    }
  }

  if (studying() && !ignoreStudyMode)
    return study(argc, argv);

  return 0;
}

#endif  // UNIT_TESTING not defined
