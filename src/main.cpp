/******************************************************************************
 The application Pic2Sym approximates images by a
 grid of colored symbols with colored backgrounds.

 Copyrights from the libraries used by the program:
 - (c) 2003-2021 Boost (www.boost.org)
     License: doc/licenses/Boost.lic
     http://www.boost.org/LICENSE_1_0.txt
 - (c) 2015-2021 OpenCV (www.opencv.org)
     License: doc/licenses/OpenCV.lic
     http://opencv.org/license/
 - (c) 1996-2021 The FreeType Project (www.freetype.org)
     License: doc/licenses/FTL.txt
     http://git.savannah.gnu.org/cgit/freetype/freetype2.git/plain/docs/FTL.TXT
 - (c) 1997-2021 OpenMP Architecture Review Board (www.openmp.org)
   (c) Microsoft Corporation (implementation for OpenMP C/C++ v2.0 March 2002)
     See: https://msdn.microsoft.com/en-us/library/8y6825x5.aspx
 - (c) 1995-2021 zlib software (Jean-loup Gailly and Mark Adler - www.zlib.net)
     License: doc/licenses/zlib.lic
     http://www.zlib.net/zlib_license.html
 - (c) 2015-2021 Microsoft Guidelines Support Library - github.com/microsoft/GSL
     License: doc/licenses/MicrosoftGSL.lic
     https://raw.githubusercontent.com/microsoft/GSL/main/LICENSE


 (c) 2016-2021 Florin Tulba <florintulba@yahoo.com>

 This program is free software: you can use its results,
 redistribute it and/or modify it under the terms of the GNU
 Affero General Public License version 3 as published by the
 Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program ('agpl-3.0.txt').
 If not, see: http://www.gnu.org/licenses/agpl-3.0.txt .
 *****************************************************************************/

#include "precompiled.h"
// This keeps precompiled.h first; Otherwise header sorting might move it

#ifndef UNIT_TESTING

#include "appStart.h"
#include "controlPanelActionsBase.h"
#include "controller.h"
#include "imgSettingsBase.h"
#include "matchSettingsBase.h"
#include "ompTraceSwitch.h"
#include "settings.h"
#include "study.h"
#include "symSettingsBase.h"

#pragma warning(push, 0)

#include <omp.h>

#include <filesystem>
#include <fstream>
#include <optional>
#include <span>
#include <string_view>

#include <gsl/gsl>

#include <opencv2/imgcodecs/imgcodecs.hpp>

#pragma warning(pop)

using namespace std;
using namespace filesystem;
using namespace cv;
using namespace gsl;

namespace pic2sym {

/// Proper usage
void showUsage() noexcept;

/// Prevents closing the console before the user sees an error message
void pauseAfterError() noexcept;

/// Presents the misidentified symbols
void viewMismatches(string_view testTitle, const Mat& mismatches) noexcept;

/// Presents the misfiltered symbols
void viewMisfiltered(string_view testTitle, const Mat& misfiltered) noexcept;

extern const string CopyrightText;
extern bool AllowReprocessingCases;

#ifdef GENERATE_OPEN_MP_TRACE
/// Definition of the lock for tracing messages generated by OMP_PRINTF().
/// osyncstream from <syncstream> works for non-printf output streaming
omp_lock_t ompTraceLock;
#endif  // defined(GENERATE_OPEN_MP_TRACE)

namespace {
/// Displays Copyright text
void copyrightNotice() noexcept {
  static const string hBar(80, '=');
  cout << hBar << '\n';
  cout << CopyrightText << '\n';
  cout << hBar << '\n' << endl;
}

/// Normal mode launch
void normalLaunch() noexcept {
  // Ensure control over the number of threads during the application
  if (omp_get_dynamic())
    omp_set_dynamic(0);

  // Use as many threads as processors
  omp_set_num_threads(omp_get_num_procs());

  // Ensure no nested parallelism
  if (omp_get_nested())
    omp_set_nested(0);

#ifdef GENERATE_OPEN_MP_TRACE
  // Initialize lock for trace messages generated by OMP_PRINTF()
  omp_init_lock(&ompTraceLock);
#endif  // defined(GENERATE_OPEN_MP_TRACE)

  copyrightNotice();

  cfg::Settings s;
  Controller c{s};

#ifdef GENERATE_OPEN_MP_TRACE
  omp_destroy_lock(&ompTraceLock);
#endif  // defined(GENERATE_OPEN_MP_TRACE)
}

/// Perform an image transformation under certain conditions.
void timingScenario(
    string_view caseName,        ///< title of the scenario
    const string& settingsPath,  ///< path towards a `p2s` file prescribing the
                                 ///< settings for the transformation
    const string& imgPath,       ///< the image to transform
    string_view reportFilePath = ""  ///< the file where to report the duration
    ) noexcept {
  AllowReprocessingCases = true;

  cfg::Settings s;
  Controller c{s};
  IControlPanelActions& cpa = c.getControlPanelActions();

  if (!cpa.loadSettings(settingsPath)) {
    cerr << caseName << "\tCouldn't load settings from `" << settingsPath << '`'
         << endl;
    return;
  }

  if (!cpa.newImage(imgPath, true)) {
    cerr << caseName << "\tCouldn't load the image `" << imgPath << '`' << endl;
    return;
  }

  cpa.newSymsBatchSize(0);  // ensure no drafts

  double durationS;
  if (!cpa.performTransformation(&durationS)) {
    cerr << caseName << "\tCouldn't start the transformation!" << endl;
    return;
  }

  if (!reportFilePath.empty()) {
    // reportFilePath.data() is NULL-terminated, as it is one of the parameters
    // passed to main
    ofstream ofs{reportFilePath.data(), ios::app};
    ofs << caseName << '\t' << durationS << endl;
  }
}

/// Returns the Mat object contained within the Unit Testing report.
optional<const Mat> contentOfReport(string_view testTitle,
                                    const string& contentDirName) noexcept {
  path contentDir{path{"."}.append("UnitTesting").append(contentDirName)};
  if (!exists(contentDir)) {
    cerr << "Expected work directory: <SolutionDir>/x64/<ConfigType>/ , "
            "but the actual one is: "
         << absolute(".") << ".\nIt has to contain folder 'UnitTesting'."
         << endl;
    pauseAfterError();
    return nullopt;
  }

  path contentFile{absolute(contentDir).append(testTitle).concat(".jpg")};
  if (!exists(contentFile)) {
    cerr << "There has to be a jpg file with the provided <testTitle> ("
         << testTitle << "), but file " << contentFile << " doesn't exist!"
         << endl;
    pauseAfterError();
    return nullopt;
  }

  const Mat content{
      imread(contentFile.string(), ImreadModes::IMREAD_UNCHANGED)};
  if (content.empty()) {
    cerr << "Invalid jpg file for " << contentDirName << ": " << contentFile
         << '.' << endl;
    pauseAfterError();
    return nullopt;
  }

  return content;
}

/**
View Mismatches Launch mode opens a Comparator window allowing the developer to
observe the less fortunate approximations of reference patches.

testTitle is the title of the Comparator window and
is also the stem of the jpg file handled by the Comparator.
*/
void viewMismatchesMode(string_view testTitle) noexcept {
  optional<const Mat> mismatches{contentOfReport(testTitle, "Mismatches")};
  if (!mismatches)
    return;

  viewMismatches(testTitle, mismatches.value());
}

/**
View Misfiltered symbols Launch mode opens a window allowing the developer to
observe the less fortunate filtered symbols.

testTitle is the title of the window and
is also the stem of the jpg file handled by the viewer.
*/
void viewMisfilteredMode(string_view testTitle) noexcept {
  optional<const Mat> misfiltered{contentOfReport(testTitle, "Misfiltered")};
  if (!misfiltered)
    return;

  viewMisfiltered(testTitle, misfiltered.value());
}

}  // anonymous namespace

}  // namespace pic2sym

/**
Starts the application in:
- study mode, when studying() is configured to return true from 'study.cpp'
- normal mode when there are no parameters
- timing mode when there are 5 parameters (how long it takes transforming an
image in a certain context)
- unit test mode for 2 provided parameters

Next to 'Pic2Sym.exe' there should be:
- res/ folder with the resources required by the application
- Pic2Sym.exe.local/ folder with the used non-system dll-s (basic Dll
redirection mechanism)

When serving the UnitTesting project, Pic2Sym.exe is called from the post-build
process of unit testing. There were 2 approaches for using Pic2Sym.exe as helper
for UnitTesting project:

I. The current method for presenting the issues found by unit testing is to
register them in a file and visualize its entries when unit testing finishes.

II. Previous approach was to invoke 'Pic2Sym.exe' through a detached process
(using CreateProcess). However, after introducing the Dll redirection mechanism:
- calling separately 'Pic2Sym.exe' with the parameters for unit testing worked
as expected
- calling 'Pic2Sym.exe' from unit testing as a detached process couldn't
localize 'qwindows.dll' from Qt. For details about that, see function
providePrivateDLLsPaths() from appStart.cpp
*/
int main(int argc, zstring<>* argv) {
  Expects(argv && argc >= 1);

  ios_base::sync_with_stdio(false);

  std::span<zstring<>> args{argv, (size_t)argc};

  using namespace pic2sym;
  AppStart::prepareEnv(args[0]);  // args[0] is a path ending in 'Pic2Sym.exe'

  // Some matters need separate studying. In that case, studying() should return
  // true. However, the study mode should be ignored when launching Pic2Sym from
  // UnitTesting or when timing scenarios, that is when the command parameters
  // look like:
  //	- mismatches ...
  //	- misfiltered ...
  //	- timing ...
  bool ignoreStudyMode{false};

  if (1 == argc) {  // no parameters
    if (!studying())
      normalLaunch();

  } else {
    const string firstParam{args[1ULL]};
    if (3 == argc) {  // 2 parameters
      const zstring<> secondParam{args[2ULL]};

      if (firstParam == "mismatches") {
        viewMismatchesMode(secondParam);
        ignoreStudyMode = true;

      } else if (firstParam == "misfiltered") {
        viewMisfilteredMode(secondParam);
        ignoreStudyMode = true;

      } else if (!studying()) {
        cerr << "Invalid first parameter " << quoted(firstParam, '\'') << endl;
        showUsage();
      }

    } else if (6 == argc) {  // 5 parameters
      if (firstParam == "timing") {
        timingScenario(args[2ULL], args[3ULL], args[4ULL], args[5ULL]);
        ignoreStudyMode = true;

      } else if (!studying()) {
        cerr << "Invalid first parameter " << quoted(firstParam, '\'') << endl;
        showUsage();
      }

    } else if (!studying()) {  // Wrong # of parameters
      cerr << "There were " << argc - 1 << " parameters!" << endl;
      showUsage();
    }
  }

  if (studying() && !ignoreStudyMode)
    return study(args);

  return 0;
}

#endif  // UNIT_TESTING not defined
